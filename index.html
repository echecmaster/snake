<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Snake personnalisable</title>
<style>
    body {
        background: #222;
        color: #fff;
        font-family: Arial, sans-serif;
        text-align: center;
    }

    canvas {
        background: #333;
        display: block;
        margin: 20px auto;
    }

    .controls {
        margin: 10px;
    }

    select, input, button {
        margin: 5px;
        padding: 5px;
    }
</style>
</head>
<body>

<h1>üêç Snake personnalisable</h1>

<div class="controls">
    <label>Grille :</label>
    <select id="gridSize">
        <option value="10">10 x 10 (facile)</option>
        <option value="25">25 x 25</option>
        <option value="50">50 x 50 (moyen)</option>
        <option value="100">100 x 100 (extr√™me)</option>
    </select>

    <label>Bonbons (1-20) :</label>
    <input type="number" id="maxCandies" min="1" max="20" value="5">

    <label>Couleur du snake :</label>
    <input type="color" id="snakeColor" value="#00ff88">

    <button onclick="startGame()">D√©marrer</button>
</div>

<p>
üç¨ Bonbons mang√©s : <span id="score">0</span> |
‚è±Ô∏è Temps : <span id="time">0</span>s
</p>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const CELL_SIZE = 25;
let gridCount;
let snake, direction, candies;
let score, timer, timeInterval, gameInterval;
let maxCandies;
let snakeColor;
let totalCells;

function startGame() {
    clearInterval(gameInterval);
    clearInterval(timeInterval);

    gridCount = parseInt(document.getElementById("gridSize").value);
    maxCandies = Math.min(20, Math.max(1, parseInt(document.getElementById("maxCandies").value)));
    snakeColor = document.getElementById("snakeColor").value;

    canvas.width = gridCount * CELL_SIZE;
    canvas.height = gridCount * CELL_SIZE;

    totalCells = gridCount * gridCount;

    snake = [{ x: 0, y: 0 }];
    direction = { x: 1, y: 0 };
    score = 0;
    timer = 0;
    candies = [];

    document.getElementById("score").textContent = score;
    document.getElementById("time").textContent = timer;

    spawnCandies();

    timeInterval = setInterval(() => {
        timer++;
        document.getElementById("time").textContent = timer;
    }, 1000);

    gameInterval = setInterval(gameLoop, 100);
}

function spawnCandies() {
    while (candies.length < maxCandies) {
        let pos = {
            x: Math.floor(Math.random() * gridCount),
            y: Math.floor(Math.random() * gridCount)
        };

        if (!snake.some(s => s.x === pos.x && s.y === pos.y)) {
            candies.push(pos);
        }
    }
}

function gameLoop() {
    const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y
    };

    // collision mur ou soi-m√™me
    if (
        head.x < 0 || head.y < 0 ||
        head.x >= gridCount || head.y >= gridCount ||
        snake.some(s => s.x === head.x && s.y === head.y)
    ) {
        if (snake.length === totalCells) {
            alert("üèÜ VICTOIRE ! Tu as rempli toute la grille !");
        } else {
            alert("üíÄ Game Over");
        }
        clearInterval(gameInterval);
        clearInterval(timeInterval);
        return;
    }

    snake.unshift(head);

    let eaten = false;
    candies = candies.filter(c => {
        if (c.x === head.x && c.y === head.y) {
            score++;
            document.getElementById("score").textContent = score;
            eaten = true;
            return false;
        }
        return true;
    });

    if (!eaten) {
        snake.pop();
    } else {
        spawnCandies();
    }

    draw();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // grille
    ctx.strokeStyle = "#444";
    for (let i = 0; i <= gridCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(canvas.width, i * CELL_SIZE);
        ctx.stroke();
    }

    // snake
    ctx.fillStyle = snakeColor;
    snake.forEach(s => {
        ctx.fillRect(
            s.x * CELL_SIZE,
            s.y * CELL_SIZE,
            CELL_SIZE,
            CELL_SIZE
        );
    });

    // bonbons
    ctx.fillStyle = "#ffffff";
    candies.forEach(c => {
        ctx.beginPath();
        ctx.arc(
            c.x * CELL_SIZE + CELL_SIZE / 2,
            c.y * CELL_SIZE + CELL_SIZE / 2,
            CELL_SIZE / 4,
            0,
            Math.PI * 2
        );
        ctx.fill();
    });
}

document.addEventListener("keydown", e => {
    switch (e.key) {
        case "ArrowUp":
            if (direction.y === 0) direction = { x: 0, y: -1 };
            break;
        case "ArrowDown":
            if (direction.y === 0) direction = { x: 0, y: 1 };
            break;
        case "ArrowLeft":
            if (direction.x === 0) direction = { x: -1, y: 0 };
            break;
        case "ArrowRight":
            if (direction.x === 0) direction = { x: 1, y: 0 };
            break;
    }
});
</script>

</body>
</html>
